---
title: "Data Import and Clean"
date: "Created: 2019-12-05 <br> Updated: `r Sys.Date()`"
---

# Overview

Import and clean data from from Filemaker Pro. 

Originally, this was an R script. But the R script was harder to troubleshoot and add exploratory/data checking stuff. Hopefully, using a markdown file with no output is the best of both worlds. Nice for interactive work, but low overhead for sourcing in other files.

## NOTES on data

2019-08-31 (From Sunil):

Originally Participant Call Log was not configured to be an exportable table,
since there was no research data coming out of there. So this table did not
include the following variables, NameFull, xRecordMonth, and xRecordYear (which
pulls in participant's full name and related record month and year respectively
from the Participant table).

On or around 8/22/19 you had asked about including the phone call log in the
Analytics section. I ran a script that updated all records in the Calls Log
with the xRecordMonth and xRecordYear, which is the modification timestamp
showing 8/22/2019 at 11:17 AM.

During the above change, I didn't pull in NameFull because of the way that
variable is configured, instead changed the code so that all future call
logs would pull in the name going forward. However, if you need the name I
can update this, not complicated to do. The modification timestamp would
update though with when I do this.

8/8/19 seems more likely to be a data entry error than a test case. The
record was created on 8/15/2019 by Jennifer (jtoro) and there are valid
records before and after with CallDate set to 8/15/2019. Also 8/8/19 is
right above 8/15/19 when using the drop-down calendar. It might make more
sense to change CallDate for that record from 8/8/19 to 8/15/19.


# Load packages and data

```{r setup, include=FALSE}
knitr::opts_chunk$set(comment = NA)
Sys.setenv(TZ = "US/Central")
```

```{r message=FALSE}
library(dplyr)
library(bfuncs)

# Used to convert dates to POSIXct
source("make_posixct.R") 
```

[top](#top)


# Connect to FM Pro

```{r}
# Open the Connection to the FM database
# Keyring notes: https://db.rstudio.com/best-practices/managing-credentials/
# Keychain error: https://github.com/r-lib/keyring/issues/45#issuecomment-332491293
con <- DBI::dbConnect(
  odbc::odbc(),
  driver   = "/Library/ODBC/FileMaker ODBC.bundle/Contents/MacOS/FileMaker ODBC",
  server   = "spsqlapwv003.sph.uthouston.edu",
  database = "DETECT",
  uid      = keyring::key_list("detect_fm_db_readonly")[1,2],
  pwd      = keyring::key_get("detect_fm_db_readonly")
)
```

```{r}
# Pull tables into R as data frames
call_log              <- DBI::dbReadTable(con, "ParticipantCallLog")
participant_scheduler <- DBI::dbReadTable(con, "ParticipantScheduler")
gift_card             <- DBI::dbReadTable(con, "GiftCard")
moca                  <- DBI::dbReadTable(con, "PhoneRecruitment")
```

```{r}
# Close the connection to the database
DBI::dbDisconnect(con)
rm(con)
```


# Initial data wrangling

  - Convert all variable names to snake case   
  - Convert timestamps to POSIXct class (combine like commands across data frames later)   

```{r}
# Convert all variable names to snake case
purrr::walk(
  # Grab the names of all data frames in the global envrironment
  .x = ls()[purrr::map_lgl(ls(), ~ is.data.frame(get(.)))],
  .f = function(x) {
    # Grab individual df from environment
    df <- get(x)
    # Grab the variables names
    var_names <- names(df)
    # Convert variable names to snake case
    var_names <- stringr::str_replace_all(var_names, '(\\B)([A-Z])', '_\\2')
    # Convert variable names to lower case
    var_names <- tolower(var_names)
    # Fix medstar_id
    var_names[var_names == "medstar_i_d"] <- "medstar_id"
    # assign back to the dataframe
    names(df) <- var_names
    # Replace df with new names in global environment
    assign(x, df, envir = .GlobalEnv)
  }
)
```




# Clean call_log

```{r}
call_log <- call_log %>% 
  mutate(
    # Change classes
    x_created_timestamp  = make_posixct(x_created_timestamp),
    x_modified_timestamp = make_posixct(x_modified_timestamp),
    call_date            = as.Date(call_date, "%m/%d/%Y"),
    # Separate date and time
    created_date = as.Date(x_created_timestamp),
    created_time = hms::as_hms(x_created_timestamp),
    # Create a call time hour variable
    call_hour = lubridate::hour(created_time),
    # Fix call_date typos
    # If call_date is earlier than created_date, then set call_date equal to 
    # the date in x_created_timestamp.
    call_date = if_else(call_date < created_date, created_date, call_date),
    # If call_date or call_time are missing, use the record created timestamp
    call_date = if_else(is.na(call_date), created_date, call_date),
    call_time = if_else(is.na(call_time), created_time, call_time),
    # Add call day variable
    day = weekdays(call_date),
    day = forcats::fct_relevel(day, "Monday", "Tuesday", "Wednesday", "Thursday", "Friday"),
    # Fill-in missing record month and year
    x_record_month = if_else(is.na(x_record_month), months(created_date), x_record_month),
    x_record_year  = if_else(is.na(x_record_year), lubridate::year(created_date), x_record_year)
  )

# Check call hours - because we sometimes have problems with this
call_hours_in_df <- sort(unique(call_log$call_hour))
call_hours_expected <- c(8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18)
if (!setequal(call_hours_in_df, call_hours_expected)) {
  stop(
    "There are unexpected call times in the call_log data. The following", 
    "times were expected: ", paste(call_hours_expected, collapse = ", "), 
    ". However, the following times appear in the data: ", 
    paste(call_hours_in_df, collapse = ", "), "."
  )
}

# Create a factor version of the call hour variable
call_log <- call_log %>% 
  mutate(call_hour_f = factor(call_hour, labels = c(
    "08-08:59", "09-09:59", "10-10:59", "11-11:59", "12-12:59", "13-13:59", 
    "14-14:59", "15-15:59", "16-16:59", "17-17:59", "18-18:59"
  )))
```




# Clean participant_scheduler

```{r}
# Keep scheduled rows only
scheduled_ids <- participant_scheduler %>% 
  filter(!is.na(appointment_date))

# Keep only the information needed for merging with call log
scheduled_ids <- scheduled_ids %>% 
  select(x_created_timestamp, medstar_id) %>% 
  mutate(
    scheduled = 1L,
    # Change classes
    x_created_timestamp  = make_posixct(x_created_timestamp),
    # Separate date and time
    scheduled_date = as.Date(x_created_timestamp),
    scheduled_time = hms::as_hms(x_created_timestamp),
    # Create a call time hour variable
    scheduled_hour = lubridate::hour(scheduled_time),
    scheduled_hour_f = factor(
      scheduled_hour, 
      levels = c(10, 11, 12, 13, 14, 15),
      labels = c("10-10:59", "11-11:59", "12-12:59", "13-13:59", "14-14:59", "15-15:59")
    )
  ) %>% 
  select(-x_created_timestamp)
```

2019-12-05: Issues to figure out

- Why are there MedstarIDs in the participant scheduler that aren't in the call log?

- Why do we have "No answer" after participant contacted?

```{r}
# Why are there MedstarIDs in the participant scheduler that aren't in the call log?
ids_ps <- participant_scheduler %>% pull(medstar_id) %>% unique()
ids_cl <- call_log %>% pull(medstar_id) %>% unique()
```

There are currently more unique ids in the participant scheduler table (1169) than the call log table (1135). Why?

```{r}
# Ids that appear in the participant scheduler, but not the call log
setdiff(ids_ps, ids_cl)
```

I'm going to manually look these up in FM Pro


# Clean gift_card

```{r}
## All we need at this point is the number of gift cards given out, i.e. rows
## in this data
n_completed <- nrow(gift_card)
```




# Clean moca

```{r}
# Deidentify data for local storage
moca_deid <- moca %>% 
  select(phone_eligible_consent:phone_more_info)
```

```{r}
# Save locally
readr::write_csv(moca_deid, "data/moca_deid.csv")
```


# Clean up environment

```{r}
# rm(make_posixct, participant_scheduler, gift_card, moca)
```


# Session information

```{r echo=FALSE}
sessionInfo()
```